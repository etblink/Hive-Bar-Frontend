"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagTransformingSanitizer = void 0;
/**
 * This file is based on https://github.com/steemit/condenser/blob/master/src/app/utils/SanitizeConfig.js
 */
const ow_1 = require("ow");
const sanitize = require("sanitize-html");
const Log_1 = require("../../../Log");
const StaticConfig_1 = require("../StaticConfig");
class TagTransformingSanitizer {
    constructor(options, localization) {
        this.sanitizationErrors = [];
        TagTransformingSanitizer.Options.validate(options);
        this.localization = localization;
        this.options = options;
    }
    sanitize(text) {
        return sanitize(text, this.generateSanitizeConfig());
    }
    getErrors() {
        return this.sanitizationErrors;
    }
    generateSanitizeConfig() {
        return {
            allowedTags: StaticConfig_1.StaticConfig.sanitization.allowedTags,
            // SEE https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
            allowedAttributes: {
                // "src" MUST pass a whitelist (below)
                iframe: [
                    "src",
                    "width",
                    "height",
                    "frameborder",
                    "allowfullscreen",
                    "webkitallowfullscreen",
                    "mozallowfullscreen",
                ],
                // class attribute is strictly whitelisted (below)
                // and title is only set in the case of a phishing warning
                div: ["class", "title"],
                // style is subject to attack, filtering more below
                td: ["style"],
                img: ["src", "alt"],
                // title is only set in the case of an external link warning
                a: ["href", "rel", "title", "class", "target"],
            },
            allowedSchemes: ["http", "https", "steem"],
            transformTags: {
                iframe: (tagName, attribs) => {
                    const srcAtty = attribs.src;
                    for (const item of StaticConfig_1.StaticConfig.sanitization.iframeWhitelist) {
                        if (item.re.test(srcAtty)) {
                            const src = typeof item.fn === "function" ? item.fn(srcAtty) : srcAtty;
                            if (!src) {
                                break;
                            }
                            const iframeToBeReturned = {
                                tagName: "iframe",
                                attribs: {
                                    frameborder: "0",
                                    allowfullscreen: "allowfullscreen",
                                    // deprecated but required for vimeo : https://vimeo.com/forums/help/topic:278181
                                    webkitallowfullscreen: "webkitallowfullscreen",
                                    mozallowfullscreen: "mozallowfullscreen",
                                    src,
                                    width: this.options.iframeWidth + "",
                                    height: this.options.iframeHeight + "",
                                },
                            };
                            return iframeToBeReturned;
                        }
                    }
                    Log_1.Log.log().warn('Blocked, did not match iframe "src" white list urls:', tagName, attribs);
                    this.sanitizationErrors.push("Invalid iframe URL: " + srcAtty);
                    const retTag = { tagName: "div", text: `(Unsupported ${srcAtty})`, attribs: {} };
                    return retTag;
                },
                img: (tagName, attribs) => {
                    if (this.options.noImage) {
                        const retTagOnImagesNotAllowed = {
                            tagName: "div",
                            text: this.localization.noImage,
                            attribs: {},
                        };
                        return retTagOnImagesNotAllowed;
                    }
                    // See https://github.com/punkave/sanitize-html/issues/117
                    const { src, alt } = attribs;
                    if (!/^(https?:)?\/\//i.test(src)) {
                        Log_1.Log.log().warn("Blocked, image tag src does not appear to be a url", tagName, attribs);
                        this.sanitizationErrors.push("An image in this post did not save properly.");
                        const retTagOnNoUrl = {
                            tagName: "img",
                            attribs: { src: "brokenimg.jpg" },
                        };
                        return retTagOnNoUrl;
                    }
                    const atts = {};
                    atts.src = src.replace(/^http:\/\//i, "//"); // replace http:// with // to force https when needed
                    if (alt && alt !== "") {
                        atts.alt = alt;
                    }
                    const retTag = { tagName, attribs: atts };
                    return retTag;
                },
                div: (tagName, attribs) => {
                    const attys = {};
                    const classWhitelist = [
                        "pull-right",
                        "pull-left",
                        "text-justify",
                        "text-rtl",
                        "text-center",
                        "text-right",
                        "videoWrapper",
                        "phishy",
                    ];
                    const validClass = classWhitelist.find((e) => attribs.class === e);
                    if (validClass) {
                        attys.class = validClass;
                    }
                    if (validClass === "phishy" && attribs.title === this.localization.phishingWarning) {
                        attys.title = attribs.title;
                    }
                    const retTag = {
                        tagName,
                        attribs: attys,
                    };
                    return retTag;
                },
                td: (tagName, attribs) => {
                    const attys = {};
                    if (attribs.style === "text-align:right") {
                        attys.style = "text-align:right";
                    }
                    const retTag = {
                        tagName,
                        attribs: attys,
                    };
                    return retTag;
                },
                a: (tagName, attribs) => {
                    let { href } = attribs;
                    if (!href) {
                        href = "#";
                    }
                    href = href.trim();
                    const attys = { href };
                    // If it's not a (relative or absolute) steemit URL...
                    if (!this.options.isLinkSafeFn(href)) {
                        // attys.target = '_blank' // pending iframe impl https://mathiasbynens.github.io/rel-noopener/
                        attys.rel = this.options.addNofollowToLinks ? "nofollow noopener" : "noopener";
                        attys.title = this.localization.phishingWarning;
                        attys.target = this.options.addTargetBlankToLinks ? "_blank" : "_self";
                    }
                    if (this.options.addCssClassToLinks) {
                        attys.class = this.options.addCssClassToLinks ? this.options.addCssClassToLinks : "";
                    }
                    const retTag = {
                        tagName,
                        attribs: attys,
                    };
                    return retTag;
                },
            },
        };
    }
}
exports.TagTransformingSanitizer = TagTransformingSanitizer;
(function (TagTransformingSanitizer) {
    let Options;
    (function (Options) {
        function validate(o) {
            (0, ow_1.default)(o.iframeWidth, "TagTransformingSanitizer.Options.iframeWidth", ow_1.default.number.integer.positive);
            (0, ow_1.default)(o.iframeHeight, "TagTransformingSanitizer.Options.iframeHeight", ow_1.default.number.integer.positive);
            (0, ow_1.default)(o.addNofollowToLinks, "TagTransformingSanitizer.Options.addNofollowToLinks", ow_1.default.boolean);
            (0, ow_1.default)(o.addTargetBlankToLinks, "TagTransformingSanitizer.Options.addTargetBlankToLinks", ow_1.default.optional.boolean);
            (0, ow_1.default)(o.addCssClassToLinks, "TagTransformingSanitizer.Options.addCssClassToLinks", ow_1.default.optional.string);
            (0, ow_1.default)(o.noImage, "TagTransformingSanitizer.Options.noImage", ow_1.default.boolean);
            (0, ow_1.default)(o.isLinkSafeFn, "TagTransformingSanitizer.Options.isLinkSafeFn", ow_1.default.function);
        }
        Options.validate = validate;
    })(Options = TagTransformingSanitizer.Options || (TagTransformingSanitizer.Options = {}));
})(TagTransformingSanitizer = exports.TagTransformingSanitizer || (exports.TagTransformingSanitizer = {}));
//# sourceMappingURL=TagTransformingSanitizer.js.map