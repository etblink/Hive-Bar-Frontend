"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var cleanStack = require("clean-stack");
var deepmerge = require("deepmerge");
var Options_1 = require("./Options");
var ChainedErrorFactory;
(function (ChainedErrorFactory) {
    function make(error, cause, appendToError, options) {
        if (options === void 0) { options = Options_1.Options.DEFAULT; }
        var chainedError = error;
        if (cause) {
            chainedError.cause = cause;
        }
        chainedError.stack = appendToStack(chainedError.stack, cause, options);
        if (appendToError) {
            appendOwnProps(chainedError, appendToError);
        }
        return chainedError;
    }
    ChainedErrorFactory.make = make;
    function appendToStack(stack, cause, options) {
        var newStack = stack || /* istanbul ignore next */ "";
        if (cause) {
            newStack += "\n Caused by: " + (cause.stack || /* istanbul ignore next */ cause);
        }
        function doCleanStack(stackToClean) {
            return cleanStack(stackToClean, { pretty: true });
        }
        if (options && options.cleanStack) {
            newStack = doCleanStack(newStack);
        }
        return newStack;
    }
    ChainedErrorFactory.appendToStack = appendToStack;
    function appendOwnProps(toObj, props) {
        for (var prop in props) {
            if (props.hasOwnProperty(prop)) {
                var shouldMerge = toObj.hasOwnProperty(prop) && typeof toObj[prop] === "object";
                toObj[prop] = shouldMerge ? deepmerge(toObj[prop], props[prop]) : props[prop];
            }
        }
    }
})(ChainedErrorFactory = exports.ChainedErrorFactory || (exports.ChainedErrorFactory = {}));
//# sourceMappingURL=ChainedErrorFactory.js.map