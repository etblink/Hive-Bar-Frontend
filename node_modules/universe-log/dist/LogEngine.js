"use strict";
/* tslint:disable:no-console */
Object.defineProperty(exports, "__esModule", { value: true });
const LiveLogConfig_1 = require("./config/LiveLogConfig");
const LogLevel_1 = require("./config/LogLevel");
const LogMetadata_1 = require("./config/LogMetadata");
const StaticConfig_1 = require("./config/StaticConfig");
const LogFormats_1 = require("./format/LogFormats");
const ParseLogMsg_1 = require("./parse/ParseLogMsg");
const Properties_1 = require("./Properties");
/**
 * Logging levels conforms NPM logging levels
 */
class LogEngine {
    constructor(props) {
        this.instanceMetadata = LogMetadata_1.LogMetadata.EMPTY_METADATA;
        if ("clone" in props) {
            this.instanceMetadata = Object.assign({}, props.clone.instanceMetadata, props.newMetadata);
            this.liveConfig = props.clone.liveConfig;
            this.logFn = props.clone.logFn;
            return;
        }
        Properties_1.Properties.validate(props);
        if (props.metadata) {
            this.instanceMetadata = props.metadata;
        }
        if (props.logFn) {
            this.logFn = props.logFn;
        }
        else {
            this.logFn = StaticConfig_1.StaticConfig.DEFAULT_LOG_FN;
        }
        const defaultFormat = props.defaultFormat ? LogFormats_1.LogFormats.valueOf(props.defaultFormat) : LogFormats_1.LogFormats.DEFAULT_FORMAT;
        this.liveConfig = new LiveLogConfig_1.LiveLogConfig({
            levelEvaluationEnvNames: props.levelEnvs || [],
            fallbackLog: this.logFn,
            defaultFormat,
        });
    }
    cloneWithMetadata(newMetadata) {
        return new LogEngine({ clone: this, newMetadata });
    }
    getLevel() {
        return this.liveConfig.getLevel();
    }
    getFormatName() {
        return this.liveConfig.getFormat().getName();
    }
    getMetadata() {
        return Object.assign({}, this.instanceMetadata, this.liveConfig.getMetadata());
    }
    /**
     * Calls generator fn only if logging level is reached.
     */
    doEfficientLog(level, msgGeneratorFn) {
        this.reevaluateConfigIfRequired();
        const levelThreshold = LogLevel_1.LogLevel.LEVELS_VALUES[this.getLevel()];
        const msgLevel = LogLevel_1.LogLevel.LEVELS_VALUES[level];
        if (msgLevel <= levelThreshold) {
            this.doLog(level, msgGeneratorFn());
        }
    }
    doLog(level, ...msgsObjs) {
        this.reevaluateConfigIfRequired();
        if (msgsObjs.length === 0) {
            return;
        }
        if (msgsObjs.length === 1 && Array.isArray(msgsObjs[0])) {
            msgsObjs = msgsObjs[0];
        }
        if (LogLevel_1.LogLevel.isLessOrEquallyVerbose({ level, threshold: this.getLevel() })) {
            const parsedMessage = ParseLogMsg_1.ParseLogMsg.parse(level, msgsObjs);
            const formattedMessage = this.liveConfig.getFormat().format(parsedMessage, this.getMetadata());
            this.rawWriteToLog(formattedMessage);
        }
    }
    rawWriteToLog(msg) {
        this.logFn(msg);
    }
    reevaluateConfigIfRequired() {
        this.liveConfig.evaluateIfRequired();
    }
}
exports.LogEngine = LogEngine;
//# sourceMappingURL=LogEngine.js.map