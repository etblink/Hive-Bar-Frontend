"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_chained_error_1 = require("typescript-chained-error");
const LogLevel_1 = require("../config/LogLevel");
const TimeUtils_1 = require("../util/TimeUtils");
class ParseLogMsg {
    static parse(level, elems) {
        let outObject = ParseLogMsg.basicLogMsg(level);
        for (const elem of elems) {
            outObject = Object.assign({}, outObject, ParseLogMsg.parseElem(elem, outObject));
        }
        return outObject;
    }
    static basicLogMsg(level) {
        return {
            time_iso: TimeUtils_1.TimeUtils.getUTCISOTime(),
            timestamp: TimeUtils_1.TimeUtils.getTimestamp(),
            level,
            level_value: LogLevel_1.LogLevel.LEVELS_VALUES[level],
        };
    }
    static parseElem(msgElem, outObj) {
        if (typeof msgElem === "string") {
            return ParseLogMsg.parseString(msgElem, outObj);
        }
        else if (msgElem instanceof Error) {
            return ParseLogMsg.parseError(msgElem, outObj);
        }
        else if (typeof msgElem === "object") {
            return ParseLogMsg.parseObject(msgElem, outObj);
        }
        else {
            return ParseLogMsg.parseOther(msgElem, outObj);
        }
    }
    static parseString(msg, outObj) {
        return { message: (outObj.message ? outObj.message + "; " : "") + msg };
    }
    static parseError(error, outObj) {
        const out = {};
        out.message = (outObj.message ? outObj.message + "; " : "") + (error + "").trim();
        if (outObj.error) {
            out.other_errors = [...(outObj.other_errors || [])];
            out.other_errors.push(ParseLogMsg.errorToObj(error));
        }
        else {
            out.error = ParseLogMsg.errorToObj(error);
        }
        return out;
    }
    static errorToObj(error) {
        if (error instanceof typescript_chained_error_1.default) {
            return Object.assign({ name: error.name, message: error.message, stack: error.stack }, (error.cause ? { cause: ParseLogMsg.errorToObj(error.cause) } : {}));
        }
        else {
            return { name: error.name, message: error.message, stack: error.stack };
        }
    }
    static parseObject(msg, outObj) {
        return Object.assign({}, msg);
    }
    static parseOther(msg, outObj) {
        return { others: [...(outObj.others || []), msg] };
    }
}
exports.ParseLogMsg = ParseLogMsg;
//# sourceMappingURL=ParseLogMsg.js.map